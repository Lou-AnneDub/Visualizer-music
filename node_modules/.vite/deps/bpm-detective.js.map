{
  "version": 3,
  "sources": ["../../bpm-detective/lib/detect.js", "../../bpm-detective/lib/index.js"],
  "sourcesContent": ["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = detect;\nvar OfflineContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;\n\n/**\n * Detect BPM of a sound source\n * @param  {AudioBuffer} buffer Sound to process\n * @return {Promise}            Resolved to detected BPM\n */\n\nfunction detect(buffer) {\n  var source = getLowPassSource(buffer);\n\n  /**\n   * Schedule the sound to start playing at time:0\n   */\n\n  source.start(0);\n\n  /**\n   * Pipe the source through the program\n   */\n\n  return [findPeaks, identifyIntervals, groupByTempo(buffer.sampleRate), getTopCandidate].reduce(function (state, fn) {\n    return fn(state);\n  }, source.buffer.getChannelData(0));\n}\n\n/**\n * Sort results by count and return top candidate\n * @param  {Object} Candidate\n * @return {Number}\n */\n\nfunction getTopCandidate(candidates) {\n  return candidates.sort(function (a, b) {\n    return b.count - a.count;\n  }).splice(0, 5)[0].tempo;\n}\n\n/**\n * Apply a low pass filter to an AudioBuffer\n * @param  {AudioBuffer}            buffer Source AudioBuffer\n * @return {AudioBufferSourceNode}\n */\n\nfunction getLowPassSource(buffer) {\n  var length = buffer.length,\n      numberOfChannels = buffer.numberOfChannels,\n      sampleRate = buffer.sampleRate;\n\n  var context = new OfflineContext(numberOfChannels, length, sampleRate);\n\n  /**\n   * Create buffer source\n   */\n\n  var source = context.createBufferSource();\n  source.buffer = buffer;\n\n  /**\n   * Create filter\n   */\n\n  var filter = context.createBiquadFilter();\n  filter.type = 'lowpass';\n\n  /**\n   * Pipe the song into the filter, and the filter into the offline context\n   */\n\n  source.connect(filter);\n  filter.connect(context.destination);\n\n  return source;\n}\n\n/**\n * Find peaks in sampleRate\n * @param  {Array} data Bugger channel data\n * @return {Array}      Peaks found that are greater than the threshold\n */\n\nfunction findPeaks(data) {\n  var peaks = [];\n  var threshold = 0.9;\n  var minThresold = 0.3;\n  var minPeaks = 15;\n\n  /**\n   * Keep looking for peaks lowering the threshold until\n   * we have at least 15 peaks (10 seconds @ 90bpm)\n   */\n\n  while (peaks.length < minPeaks && threshold >= minThresold) {\n    peaks = findPeaksAtThreshold(data, threshold);\n    threshold -= 0.05;\n  }\n\n  /**\n   * Too fiew samples are unreliable\n   */\n\n  if (peaks.length < minPeaks) {\n    throw new Error('Could not find enough samples for a reliable detection.');\n  }\n\n  return peaks;\n}\n\n/**\n * Function to identify peaks\n * @param  {Array}  data      Buffer channel data\n * @param  {Number} threshold Threshold for qualifying as a peak\n * @return {Array}            Peaks found that are grater than the threshold\n */\n\nfunction findPeaksAtThreshold(data, threshold) {\n  var peaks = [];\n\n  /**\n   * Identify peaks that pass the threshold, adding them to the collection\n   */\n\n  for (var i = 0, l = data.length; i < l; i += 1) {\n    if (data[i] > threshold) {\n      peaks.push(i);\n\n      /**\n       * Skip forward ~ 1/4s to get past this peak\n       */\n\n      i += 10000;\n    }\n  }\n\n  return peaks;\n}\n\n/**\n * Identify intervals between peaks\n * @param  {Array} peaks Array of qualified peaks\n * @return {Array}       Identifies intervals between peaks\n */\n\nfunction identifyIntervals(peaks) {\n  var intervals = [];\n\n  peaks.forEach(function (peak, index) {\n    var _loop = function _loop(i) {\n      var interval = peaks[index + i] - peak;\n\n      /**\n       * Try and find a matching interval and increase it's count\n       */\n\n      var foundInterval = intervals.some(function (intervalCount) {\n        if (intervalCount.interval === interval) {\n          return intervalCount.count += 1;\n        }\n      });\n\n      /**\n       * Add the interval to the collection if it's unique\n       */\n\n      if (!foundInterval) {\n        intervals.push({\n          interval: interval,\n          count: 1\n        });\n      }\n    };\n\n    for (var i = 0; i < 10; i += 1) {\n      _loop(i);\n    }\n  });\n\n  return intervals;\n}\n\n/**\n * Factory for group reducer\n * @param  {Number} sampleRate Audio sample rate\n * @return {Function}\n */\n\nfunction groupByTempo(sampleRate) {\n\n  /**\n   * Figure out best possible tempo candidates\n   * @param  {Array} intervalCounts List of identified intervals\n   * @return {Array}                Intervals grouped with similar values\n   */\n\n  return function (intervalCounts) {\n    var tempoCounts = [];\n\n    intervalCounts.forEach(function (intervalCount) {\n      if (intervalCount.interval !== 0) {\n        /**\n         * Convert an interval to tempo\n         */\n\n        var theoreticalTempo = 60 / (intervalCount.interval / sampleRate);\n\n        /**\n         * Adjust the tempo to fit within the 90-180 BPM range\n         */\n\n        while (theoreticalTempo < 90) {\n          theoreticalTempo *= 2;\n        }while (theoreticalTempo > 180) {\n          theoreticalTempo /= 2;\n        } /**\n           * Round to legible integer\n           */\n\n        theoreticalTempo = Math.round(theoreticalTempo);\n\n        /**\n         * See if another interval resolved to the same tempo\n         */\n\n        var foundTempo = tempoCounts.some(function (tempoCount) {\n          if (tempoCount.tempo === theoreticalTempo) {\n            return tempoCount.count += intervalCount.count;\n          }\n        });\n\n        /**\n         * Add a unique tempo to the collection\n         */\n\n        if (!foundTempo) {\n          tempoCounts.push({\n            tempo: theoreticalTempo,\n            count: intervalCount.count\n          });\n        }\n      }\n    });\n\n    return tempoCounts;\n  };\n}", "module.exports = require('./detect').default;\n"],
  "mappings": "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",
  "names": ["_loop", "i"]
}
